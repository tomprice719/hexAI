"""
Utilities for training and analyzing the performance of models.
"""
from . import smart_games
from . import dumb_games
from .training_data import make_training_data
from .board_utils import Board, Player
from .config import board_size, num_initial_moves
import numpy as np
import itertools


def compare_models(model_a, model_b, num_games, verbose=True):
    """
    Plays some number of hex games with two models.
    Prints and returns information summarizing the results.
    """
    results = [(winner, swapped)
               for game, winner, swapped
               in smart_games.make_games(model_a,
                                         model_b,
                                         num_games,
                                         num_initial_moves)]
    model1_wins = results.count((Player.RED, False)) + results.count((Player.BLUE, True))
    win_ratio = (model1_wins / num_games)
    if verbose:
        for winner, swapped in itertools.product(Player, (False, True)):
            print("winner: %s, swapped: %s, count: %d" %
                  (winner.name, swapped, results.count((winner, swapped))))
        print("win ratio %f" % win_ratio)
    return win_ratio


def show_game(model_a, model_b, num_games=1):
    """
    Plays a game of hex, or several games, and prints each move.
    """
    games = smart_games.make_games(model_a, model_b, num_games, num_initial_moves, batch_size=1)
    for moves, winner, swapped in games:
        b = Board(board_size)
        for i, (move, annotation) in enumerate(moves):
            b.update(Player(i % 2), move)
            print(b)
            print(annotation)
            print("-------------------------------------")
        print("winner:", winner, "swapped:", swapped)
        print()


def train_from_selfplay(model, new_games_per_epoch, num_iterations, use_weight=False):
    """
    Generates games from having a model play against itself,
    then uses these games as training data to improve the model.
    """
    for i in range(num_iterations):
        if i % 10 == 0:
            print("At iteration %d" % i)
        games = smart_games.make_games(
            model,
            model,
            new_games_per_epoch,
            num_initial_moves,
            allow_swap=False
        )
        assert len(games) == new_games_per_epoch
        positions, winners, move_numbers = make_training_data(games, num_initial_moves)

        model.fit(
            positions,
            winners,
            batch_size=64,
            epochs=1,
            shuffle=True,
            verbose=0,
            sample_weight=1 / move_numbers if use_weight else None
        )


def train_from_file(model, filename, num_epochs):
    """
    Trains a model from a file containing the training data.
    """
    data = dict(np.load("data/%s" % filename))

    model.fit(
        data,
        data,
        batch_size=64,
        epochs=num_epochs,
        shuffle=True,
        validation_split=0.05
    )


def make_initial_training_data(num_games, filename=None):
    """
    Creates training data from games generated by a simple algorithm that requires no model,
    to be used for the first step of training before training from self-play.
    """
    games = dumb_games.make_games(num_games)
    return make_training_data(games, 0, filename)
